import java_cup.runtime.*;
   
parser code {:
    boolean syntaxErrors = true;
    
    public void report_error(String message, Object info) {
        
        StringBuilder m = new StringBuilder("Error");
   
        if (info instanceof java_cup.runtime.Symbol) {
            java_cup.runtime.Symbol s = ((java_cup.runtime.Symbol) info);
   
            if (s.left >= 0) {                
                m.append(" in line "+(s.left+1));   
                if (s.right >= 0)                    
                    m.append(", column "+(s.right+1));
            }
        }
   
        m.append(" : "+message);
   
        System.err.println(m);
    }
   
    public void report_fatal_error(String message, Object info) {
        report_error(message, info);
        System.exit(1);
    }
    public void syntax_error(Symbol current_token) {
        System.out.println("failed symbol: " + current_token.toString());
        report_error("Syntax error at line " + (current_token.left+1) + ", column "+ current_token.right, null);
    }

:};


terminal PLUS, SEMI, CHAR, CHARCONST, BOOL, INT, RAT, FLOAT, TOP, PRINT, THEN, ELSE, IF, FI, WHILE, DO, OD, FORALL, IN, RETURN, DIV, MULT, SUBTRACT, ASSIGN, EQ, NOTEQ, AND, OR, COLON, LPAREN, RPAREN, LBRACE, RBRACE, LBRACKET, RBRACKET, FDEF, MAIN, DICT, SEQ, BOOLCONST, NUM, ID, LANGLE, COMMA, RANGLE, POW, NOT, LTEQ, CONCAT, IMPLIES, LEN, TDEF, ALIAS, STRING, MAPSTO, ERROR;

/* Non terminals */
non terminal            S, decList, dec, funcDef, main, params, moreParams, returnType, type;
non terminal            typeDef, typeFields, moreTypeFields, aliasDec, varDec, varInit, varAssignment;
non terminal            expression, arithExpression, boolExpression;
non terminal            body, statement, moreStatements, statementList, controlFlow;
non terminal            aggregateType, dictType, seqLiteral, dictLiteral;
non terminal            keyValPair, keyValPairList, moreKeyPairs, seqValList, moreSeqVals;
non terminal            alphaBody, alphaDec, debugVarDec, type_or_alias;

/* Precedences */
precedence left OR;
precedence left AND;
precedence left IMPLIES;
precedence left NOT;
precedence left NOTEQ;
precedence left EQ;
precedence left LTEQ;
precedence left LANGLE;
precedence left SUBTRACT;
precedence left PLUS;
precedence left DIV;
precedence left MULT;
precedence left POW;
precedence left ID;


/* The grammar rules */

S         ::= decList main decList          {: System.out.println("Successful Test");:}
            ;

main      ::= MAIN                         {: System.out.println("Main");:}
            ;

decList   ::=                               {: System.out.println("\n\t^ End of decList");:}
            | dec decList                   
            ;

dec       ::= funcDef                       {: System.out.println("\n\t^ End Of Function Definition");:} 
            | typeDef                       {: System.out.println("End Of Type Definition");:} 
            | aliasDec                      {: System.out.println("Alias Declaration");:} 
            | varDec                        {: System.out.println("Variable Declaration");:} 
            ;

funcDef   ::= FDEF ID LPAREN params RPAREN LBRACE alphaBody RBRACE returnType SEMI
            ;

params    ::= 
            | ID COLON type_or_alias moreParams
            ;

moreParams ::=
             | COMMA params
             ;

returnType ::=
             | COLON type_or_alias
             ;

type       ::= FLOAT 
             | INT 
             | RAT 
             | BOOL 
             | CHAR 
             | TOP 
             | aggregateType
             ;

typeDef   ::= TDEF ID LBRACE typeFields RBRACE SEMI
            ;

typeFields ::= ID COLON type_or_alias moreTypeFields
             ;

type_or_alias ::= type
           | ID
           ;

moreTypeFields ::=
                 | COMMA typeFields
                 ;

aliasDec ::= ALIAS type ID SEMI
           ;

varDec ::= ID COLON type varInit SEMI
         ;

varInit ::=
          | ASSIGN expression               {: System.out.print("(Initialised) ");:}
          ;

varAssignment ::= ID ASSIGN expression      {: System.out.println("Variable Assignment");:}
                ;


alphaBody ::= alphaDec alphaBody
            | debugVarDec alphaBody
            | statementList
            ;

alphaDec ::= funcDef
           | typeDef
           | aliasDec
           ;

/*  Necessary for printing out var dec in correct place  */
debugVarDec ::= varDec     {: System.out.println("Variable Declaration");:} 
              ;

body ::= decList statementList     
       ;

statementList ::= statement moreStatements
                ;

moreStatements ::=
                 | statementList
                 ;

statement ::= varAssignment SEMI                
            | controlFlow                           
            ;

controlFlow ::= WHILE LPAREN expression RPAREN DO body OD
              | FORALL LPAREN expression IN expression RPAREN DO body OD
              | IF LPAREN expression RPAREN THEN body FI
              | IF LPAREN expression RPAREN THEN body ELSE body FI
              | RETURN expression SEMI                                        {: System.out.println("Return Statement");:}
              ;

expression ::= ID                   
             | arithExpression              
             | boolExpression               
             | BOOLCONST
             | CHARCONST                  
             | NUM                          
             | STRING
             | dictLiteral
             | seqLiteral
             ;

dictLiteral ::= LBRACE keyValPairList RBRACE
              ;

keyValPairList ::= 
                 | keyValPair moreKeyPairs
                 ;

moreKeyPairs ::= 
               | COMMA keyValPair moreKeyPairs
               ;

keyValPair ::= expression MAPSTO expression
             ;

seqLiteral ::= LBRACKET seqValList RBRACKET
             ;

seqValList ::= 
             | expression moreSeqVals
             ;

moreSeqVals ::= 
              | COMMA expression moreSeqVals
              ;

aggregateType ::= DICT LANGLE dictType RANGLE
                | SEQ LANGLE type_or_alias RANGLE
                ;

dictType ::= type_or_alias COMMA type_or_alias
           ;

arithExpression ::= expression PLUS expression
                  | expression SUBTRACT expression
                  | expression MULT expression
                  | expression DIV expression
                  | expression POW expression
                  ;

boolExpression ::= NOT expression
                 | expression EQ expression
                 | expression NOTEQ expression
                 | expression AND expression
                 | expression OR expression
                 | expression IMPLIES expression
                 ;
