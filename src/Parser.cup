import java_cup.runtime.*;
   
parser code {:
    boolean syntaxErrors = true;
    
    public void report_error(String message, Object info) {
        
        StringBuilder m = new StringBuilder("Error");
   
        if (info instanceof java_cup.runtime.Symbol) {
            java_cup.runtime.Symbol s = ((java_cup.runtime.Symbol) info);
   
            if (s.left >= 0) {                
                m.append(" in line "+(s.left+1));   
                if (s.right >= 0)                    
                    m.append(", column "+(s.right+1));
            }
        }
   
        m.append(" : "+message);
   
        System.err.println(m);
    }
   
    public void report_fatal_error(String message, Object info) {
        report_error(message, info);
        System.exit(1);
    }
    public void syntax_error(Symbol current_token) {
        syntaxErrors = true;
        System.out.println("failed symbol: " + current_token.toString());
        report_error("Syntax error at line " + (current_token.left+1) + ", column "+ current_token.right, null);
    }

:};


terminal PLUS, SEMI, CHAR, CHARCONST, BOOL, INT, RAT, FLOAT, TOP, PRINT, THEN, ELSE, IF, FI, WHILE, DO, OD, FORALL, IN, RETURN, DIV, MULT, SUBTRACT, ASSIGN, EQ, NOTEQ, AND, OR, COLON, LPAREN, RPAREN, LBRACE, RBRACE, LBRACKET, RBRACKET, FDEF, MAIN, DICT, SEQ, BOOLCONST, NUM, ID, LANGLE, COMMA, RANGLE, POW, NOT, LTEQ, CONCAT, IMPLIES, LEN, TDEF, ALIAS, STRING, ERROR;

/* Non terminals */
non terminal            S, decList, dec, funcDef, main, params, moreParams, returnType, type;
non terminal            typeDef, typeFields, moreTypeFields, aliasDec, varDec, varInit, varAssignment;
non terminal            expression, expressionMk2, arithExpression, boolExpression;
non terminal            body, statement, moreStatements, statementList, controlFlow;
non terminal            aggregateType, dictType, seqLiteral, dictLiteral;
non terminal            keyValPair, keyValPairList, moreKeyPairs, seqValList, moreSeqVals;
non terminal            alphaBody, alphaDec, debugVarDec, type_or_alias, returnStatement, seqSlicing, functionCall, csExpressions;

/* Precedences */
precedence left OR;
precedence left AND;
precedence left IMPLIES;
precedence left NOT;
precedence left NOTEQ;
precedence left EQ;
precedence left LTEQ;
precedence left LANGLE;
precedence left SUBTRACT;
precedence left PLUS;
precedence left DIV;
precedence left MULT;
precedence left POW;
precedence left ID;


/* The grammar rules */

S         ::= decList main decList          {: System.out.println("-----------------\nSuccessful Test\n-----------------");:}
            ;

main      ::= MAIN LBRACE body RBRACE SEMI       {: System.out.println("Main");:}
            ;

decList   ::=                               
            | dec decList                   
            ;

dec       ::= funcDef                       {: System.out.println("\n\t^ End Of Function Definition");:} 
            | typeDef                       {: System.out.println("End Of Type Definition");:} 
            | aliasDec                      {: System.out.println("Alias Declaration");:} 
            | varDec                        {: System.out.println("Variable Declaration");:} 
            ;

funcDef   ::= FDEF ID LPAREN params RPAREN LBRACE alphaBody RBRACE returnType SEMI
            ;

params    ::= 
            | ID COLON type_or_alias moreParams
            ;

moreParams ::=
             | COMMA params
             ;

returnType ::=
             | COLON type_or_alias
             ;

type       ::= FLOAT 
             | INT 
             | RAT 
             | BOOL 
             | CHAR 
             | TOP 
             | aggregateType
             ;

typeDef   ::= TDEF ID LBRACE typeFields RBRACE SEMI
            ;

typeFields ::= ID COLON type_or_alias moreTypeFields
             ;

type_or_alias ::= type
           | ID
           ;

moreTypeFields ::=
                 | COMMA typeFields
                 ;

aliasDec ::= ALIAS type ID SEMI
           ;

varDec ::= ID COLON type_or_alias varInit SEMI
         ;

varInit ::=
          | ASSIGN expressionMk2               {: System.out.print("(Initialised) ");:}
          ;

varAssignment ::= ID ASSIGN expressionMk2      {: System.out.println("Variable Assignment");:}
                ;


alphaBody ::= alphaDec alphaBody
            | debugVarDec alphaBody
            | statementList
            ;

alphaDec ::= funcDef
           | typeDef
           | aliasDec
           ;

/*  Necessary for printing out var dec in correct place  */
debugVarDec ::= varDec     {: System.out.println("Variable Declaration");:} 
              ;

body ::= decList statementList     
       ;

statementList ::= statement moreStatements
                ;

moreStatements ::=
                 | statementList
                 ;

statement ::= varAssignment SEMI                
            | controlFlow    
            | functionCall SEMI                       
            ;

controlFlow ::= WHILE LPAREN expressionMk2 RPAREN DO body OD
              | FORALL LPAREN expressionMk2 IN expressionMk2 RPAREN DO body OD
              | IF LPAREN expressionMk2 RPAREN THEN body FI
              | IF LPAREN expressionMk2 RPAREN THEN body ELSE body FI
              | RETURN returnStatement SEMI                               {: System.out.println("Return Statement");:}
              ;

returnStatement ::= 
                  | expressionMk2
                  ;

expressionMk2 ::= LPAREN expressionMk2 RPAREN   {: System.out.println("Ya'll");:}
                | expression
                ;

expression ::= ID                   
             | arithExpression            
             | boolExpression               
             | BOOLCONST
             | CHARCONST                  
             | NUM                          
             | STRING
             | dictLiteral
             | seqLiteral
             | seqSlicing   // also used for indexing
             | functionCall
             ;

functionCall ::= ID LPAREN csExpressions RPAREN
               ;

csExpressions ::= 
                | expressionMk2
                | expressionMk2 COMMA csExpressions
                ;

seqSlicing ::= ID LBRACKET expressionMk2 COLON expressionMk2 RBRACKET
             | ID LBRACKET COLON expressionMk2 RBRACKET
             | ID LBRACKET expressionMk2 COLON RBRACKET
             | ID LBRACKET expressionMk2 RBRACKET
             ;

dictLiteral ::= LBRACE keyValPairList RBRACE
              ;

keyValPairList ::= 
                 | keyValPair moreKeyPairs
                 ;

moreKeyPairs ::= 
               | COMMA keyValPair moreKeyPairs
               ;

keyValPair ::= expressionMk2 COLON expressionMk2
             ;

seqLiteral ::= LBRACKET seqValList RBRACKET
             ;

seqValList ::= 
             | expressionMk2 moreSeqVals
             ;

moreSeqVals ::= 
              | COMMA expressionMk2 moreSeqVals
              ;

aggregateType ::= DICT LANGLE dictType RANGLE
                | SEQ LANGLE type_or_alias RANGLE
                ;

dictType ::= type_or_alias COMMA type_or_alias
           ;

arithExpression ::= expressionMk2 PLUS expressionMk2
                  | expressionMk2 SUBTRACT expressionMk2
                  | expressionMk2 MULT expressionMk2
                  | expressionMk2 DIV expressionMk2
                  | expressionMk2 POW expressionMk2
                  ;

boolExpression ::= NOT expressionMk2
                 | expressionMk2 LANGLE expressionMk2
                 | expressionMk2 LTEQ expressionMk2
                 | expressionMk2 EQ expressionMk2
                 | expressionMk2 NOTEQ expressionMk2
                 | expressionMk2 AND expressionMk2
                 | expressionMk2 OR expressionMk2
                 | expressionMk2 IMPLIES expressionMk2
                 ;
